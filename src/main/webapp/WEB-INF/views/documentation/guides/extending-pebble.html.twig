{% extends "documentation/guides/guide" %}

{% block guideTitle %}Extending Pebble{% endblock %}

{% block guideContent %}
	<h3>Overview</h3>
	<p>
		Pebble was designed to be flexible and accomodate the requirements of any project. You
		can add your own tags, functions, operators, filters, tests, and global variables. 
		The majority of these are quite trivial to implement. 
	</p>
	
	<p>
		Begin by creating a 
		class that implements {{ api(currentVersion, 'extension', 'Extension') }}. For your
		own convenience, I recommend extending 
		{{ api(currentVersion, 'extension', 'AbstractExtension') }} if you can. After 
		implementing the required methods, register your extension with the PebbleEngine 
		before compiling any templates:
		<pre>{{ '
PebbleEngine engine = new PebbleEngine();
engine.addExtension(new MyCustomExtension());' | trim | escape }}</pre>
	</p>		

	<h3>Filters</h3>
	<p>
		A filter is designed to modify existing data, not provide new data. To create
		custom filters, implement the <code>getFilters()</code> method of your extension which
		will return a <code>List</code> of {{ api(currentVersion, 'extension', 'Filter') }} objects. 
		The	{{ api(currentVersion, 'extension', 'Filter') }} interface requires two methods, one which simply returns the name
		of the filter and the other being the actual application of the filter. The first argument of the <code>apply(...)</code> method
		is the data to be filtered and the second argument is the list of arguments the user may have provided. Because Pebble is dynamically typed, you will
		have to downcast the arguments to the desired type. Here is an example of how the <code><a href="../filter/upper">upper</a></code>
		filter might be implemented:
		<pre>{{ '
public UpperFilter implements Filter {

	public String getName(){
		return "upper";
	}
	
	public Object apply(Object input, List<Object> args){
		if(input == null){
			return null;
		}
		String str = (String) input;
		return str.toUpperCase();
	}

}' | trim | escape }}</pre>
	</p>
	
	<h3>Tests</h3>
	<p>
		Adding custom tests is very similar to custom filters. Implement the <code>getTests()</code>
		method within your extension which will return a <code>List</code> of 
		{{ api(currentVersion, 'extension', 'Test') }} objects.
		The	{{ api(currentVersion, 'extension', 'Test') }} interface requires two methods, one which simply returns the name
		of the test and the other being the actual application of the test which returns a boolean value. 
		The first argument of the <code>apply(...)</code> method is the data to be tested and the
		second argument is the list of arguments the user may have provided.
		 Here is an example of how the <code><a href="../test/even">even</a></code>
		test might be implemented:
		<pre>{{ '
public EvenTest implements Test {

	public String getName(){
		return "even";
	}
	
	public boolean apply(Object input, List<Object> args){		
		Integer in = (Integer) input;
		return (in % 2 == 0);
	}

}' | trim | escape }}</pre>
	</p>
	
	<h3>Functions</h3>
	<p>
		Adding functions is also very similar to custom filters. First and foremost, it's important
		to understand the different intentions behind a function and a filter because it can often be
		ambiguous which one should be implemented. A filter is intended to modify existing content
		where a filter is moreso intended to produce new content. 
	</p>
	<p>
		To add functions, implement the <code>getFunctions()</code>
		method within your extension which will return a <code>List</code> of 
		{{ api(currentVersion, 'extension', 'SimpleFunction') }} objects.
		The	{{ api(currentVersion, 'extension', 'SimpleFunction') }} interface requires two methods, one which simply returns the name
		of the function and the other being the actual application of the function. 
		The only argument of the <code>execute(...)</code> method is a list of arguments the user may have provided.
		 Here is an example of how a fictional <code>fibonacciString</code> function  
		might be implemented:
		<pre>{{ '
public FibonnaciStringFunction implements SimpleFunction() {

		public String getName() {
			return "fibonacciString";
		}

		public Object execute(List<Object> args) {
			Integer length = (Integer)args.get(0);
			Integer prev1 = 0;
			Integer prev2 = 1;
			
			StringBuilder result = new StringBuilder();
			
			result.append("01");
			
			for(int i = 2; i < length; i++){
				Integer next = prev1 + prev2;
				result.append(next);
				prev1 = prev2;
				prev2 = next;
			}
			return result.toString();

		}
}' | trim | escape }}</pre>
	</p>
	
	<h3>Global Variables</h3>
	<p>
		Adding global variables, which are variables that are accessbile to all templates, is very trivial. In your
		custom extension, implement the <code>getGlobalVariables()</code> method which returns
		a <code>Map&lt;String,Object&gt;</code>. The contents of this <code>Map</code> will be 
		merged into the context you provide to each template at the time of rendering.
	</p>
	
	<h3>Operators</h3>
	<p>
		Operators are more complex to implement than filters or tests. 
		To add custom operators, implement the <code>getBinaryOperators()</code>
		or the <code>getUnaryOperators()</code> method in your extension, or both. 
		These methods return a <code>List</code> of 
		{{ api(currentVersion, 'operator', 'BinaryOperator') }} or 
		{{ api(currentVersion, 'operator', 'UnaryOperator') }} objects, respectively.
	</p>
	<p>
		Binary operators require the following information:
		<ul>
			<li>Precedence: an integer relative to other operators which defines the order of operations.</li>
			<li>Symbol: a String representing the actual operator. This is typically a single character but doesn't have to be.</li>
			<li>Node Class: A {{ api(currentVersion, 'node', 'Node') }} implementation which extends {{ api(currentVersion, 'node/expression', 'NodeExpressionBinary') }}. This class is responsible for the compilation of your operator to Java.</li>
			<li>Associativity: Either left or right depending on how the operator is used.</li>
		</ul>
	</p>
	<p>
		A unary operator is much the same except it's node class must extend
		{{ api(currentVersion, 'node/expression', 'NodeExpressionUnary ') }} and
		there is no associativity.
	</p>
	<p>
		The precedence values for existing core operators are as followed:
		<ul>
			<li><code>or</code> - 10</li>
			<li><code>and</code> - 15</li>
			<li><code>==</code> - 20</li>
			<li><code>!=</code> - 20</li>
			<li><code>&gt;</code> - 20</li>
			<li><code>&lt;</code> - 20</li>
			<li><code>&gt;=</code> - 20</li>
			<li><code>&lt;=</code> - 20</li>
			<li><code>+</code> - 30</li>
			<li><code>-</code> - 30</li>
			<li><code>not</code> - 50 (Unary)</li>
			<li><code>*</code> - 60</li>
			<li><code>/</code> - 60</li>
			<li><code>%</code> - 60</li>
			<li><code>is</code> - 100</li>
			<li><code>is not</code> - 100</li>
			<li><code>+</code> - 500 (Unary)</li>
			<li><code>-</code> - 500 (Unary)</li>
		</ul>
	</p>
	<p>
		The following is an	example of how the addition operator (<code>+</code>) might have been 
		implemented:
	</p>
			<pre>{{ '
public AdditionOperator implements BinaryOperator {

	public int getPrecedence(){
		return 30;
	}
	
	public String getSymbol(){
		return "+";
	}
	
	public Class<? extends NodeExpressionBinary> getNodeClass(){
		return AdditionNode.class;
	}
	
	public Associativity getAssociativity(){
		return Associativity.LEFT;
	}

}' | trim | escape }}</pre>
	<p>
		Alongside each Operator class you will also need to implement a corresponding
		{{ api(currentVersion, 'node', 'Node') }} class which defines how the operator gets compiled into Java. The above
		example references a fictional <code>AdditionNode.class</code>. 
	</p>
	<p> 
		Here is what the <code>AdditionNode</code> class might look like:
	</p>
			<pre>{{ '
public AdditionNode extends NodeExpressionBinary {

	public void compile(Compiler compiler){
		compiler.raw("(");
			.subcompile(leftExpression);
			.raw(" + ")
			.subcompile(rightExpression)
			.raw(")");
	}

}' | trim | escape }}</pre>
	<p>
		The provided {{ api(currentVersion, 'compiler', 'Compiler') }} object uses the builder design pattern and provides methods
		to help you generate beautiful and readable Java code:
	
		<ul>
			<li><code>subcompile(Node node)</code>: Compiles a node.</li>
			<li><code>write(String string)</code>: Writes the given string, prefixed with indentation.</li>
			<li><code>raw(String string)</code>: Writes the given string as is.</li>
			<li><code>string(String string)</code>: Writes a quoted Java string.</li>
			<li><code>indent()</code>: Increases the indentation.</li>
			<li><code>outdent()</code>: Decreases the indentation.</li>
		</ul>
	</p>
	<p>
		In the above example you will notice that children of NodeExpressionBinary
		have access to two other node classes, <code>leftExpression</code>, and 
		<code>rightExpression</code>; these are the operands of your operator.
	</p>
	
	<h3>Tags</h3>
	<p>
		Creating new tags is one of the most powerful abilities of Pebble although it is
		not trivial. Your extension should start by implementing the <code>getTokenParsers()</code>
		method. A {{ api(currentVersion, 'tokenParser', 'TokenParser') }} is responsible for converting all necessary 
		tokens to appropriate Nodes. A token is a whitespace delimited group of characters found in a the template
		and a {{ api(currentVersion, 'node', 'Node') }} is a Pebble class that is responsible for compiling itself to Java.
	</p>
	<p>
		Let us look at an example of a {{ api(currentVersion, 'tokenParser', 'TokenParser') }}:
	</p>
		<pre>{{ '
public SetTokenParser extends AbstractTokenParser {

	public String getTag(){
		return "set";
	}

	public Node parse(Token token) throws SyntaxException {
		TokenStream stream = this.parser.getStream();
		int lineNumber = token.getLineNumber();
		
		// skip the "set" token
		stream.next();

		NodeExpressionDeclaration name = this.parser.getExpressionParser().parseDeclarationExpression();

		stream.expect(Token.Type.PUNCTUATION, "=");
		
		NodeExpression value = this.parser.getExpressionParser().parseExpression();

		stream.expect(Token.Type.EXECUTE_END);

		return new NodeSet(lineNumber, name, value);
	}

}' | trim | escape }}</pre>
	<p>
		The <code>getTag()</code> method must return the name of the tag. Pebble's main parser
		will use this name to determine when to delegate responsibility to your custom TokenParser.
		This example is parsing the <code>set</code> tag.
	</p>
	<p>
		The parse method is invoked whenever the primary parser encounters a 
		<code>set</code> token. This method should return one {{ api(currentVersion, 'node', 'Node') }} instance
		which may or may not contain children nodes. Creating Nodes was described
		above, in the section on how to create custom operators.
	</p>
	<p>
		The best way to learn all the details of parsing is to look at some of
		the tools used, as well as some examples. Here is a list of classes I 
		suggest reading:
		<ul>
			<li><code>{{ api(currentVersion, 'tokenParser', 'TokenParser') }}</code></li>
			<li><code>{{ api(currentVersion, 'parser', 'Parser') }}</code></li>
			<li><code>{{ api(currentVersion, 'tokenParser', 'SetTokenParser') }}</code></li>
			<li><code>{{ api(currentVersion, 'tokenParser', 'BlockTokenParser') }}</code></li>
		</ul> 
	</p>
	
{% endblock %}