{% extends "documentation/guides/guide" %}

{% block guideTitle %}Extending Pebble{% endblock %}

{% block guideContent %}
	<h3>Overview</h3>
	<p>
		Pebble was designed to be flexible and accomodate the requirements of any project. You
		can add your own tags, operators, filters, and tests. All of these are quite trivial to
		implement except for custom tags but fortunately it's very rare to require a custom tag. 
	</p>
	
	<p>
		To create an extension which will provide all the filters, test, etc, create a
		class that implements <code>com.mitchellbosecke.pebble.extension.Extension</code>. For your
		own convenience, I recommend extending 
		<code>com.mitchellbosecke.pebble.extension.AbstractExtension</code> if you can. After 
		implementing the required methods, register your extension class with the PebbleEngine 
		before compiling any templates:
		<pre>{{ '
PebbleEngine engine = new PebbleEngine();
engine.addExtension(new MyCustomExtension());' | trim | escape }}</pre>
	</p>		

	<h3>Filters</h3>
	<p>
		A filter is designed to modify existing data, not provide new data. To provide
		custom filters, implement the <code>getFilters()</code> method of your extension which
		will return a <code>List</code> of <code>com.mitchellbosecke.pebble.filter.Filter</code> objects. 
		The	<code>Filter</code> interface requires two methods, one which simply returns the name
		of the filter and the other is the actual application of the filter. The <code>apply(...)</code> method
		will be given an <code>Object</code> which is the data to be filtered as well as a 
		<code>List&lt;Object&gt;</code> containing any other arguments the user may have
		provided. Here is an example of how the <code><a href="../filter/upper">upper</a></code>
		filter might be implemented:
		<pre>{{ '
public UpperFilter implements Filter {

	public String getName(){
		return "upper";
	}
	
	public Object apply(Object input, List<Object> args){
		String str = (String) input;
		return str.toUpperCase();
	}

}' | trim | escape }}</pre>
	</p>
	
	<h3>Tests</h3>
	<p>
		Adding custom tests is very similar to custom filters. Implement the <code>getTests()</code>
		method within your extension which will return a <code>List</code> of 
		<code>com.mitchellbosecke.pebble.test.Test</code> objects.
		The	<code>Test</code> interface requires two methods, one which simply returns the name
		of the test and the other is the actual application of the test which returns a boolean value. 
		The <code>apply(...)</code> method
		will be given an <code>Object</code> which is the data to be tested as well as a 
		<code>List&lt;Object&gt;</code> containing any other arguments the user may have
		provided. Here is an example of how the <code><a href="../test/even">even</a></code>
		test might be implemented:
		<pre>{{ '
public EvenTest implements Test {

	public String getName(){
		return "even";
	}
	
	public Boolean apply(Object input, List<Object> args){
		Integer in = (Integer) input;
		return (in % 2 == 0);
	}

}' | trim | escape }}</pre>
	</p>
	
	<h3>Operators</h3>
	<p>
		To add custom operators, implement the <code>getBinaryOperators()</code>
		or the <code>getUnaryOperators()</code> method in your extension, or both.
		These methods each return a <code>List</code> of either
		<code>com.mitchellbosecke.pebble.operator.BinaryOperator</code> or 
		<code>com.mitchellbosecke.pebble.operator.UnaryOperator</code> objects.
	</p>
	<p>
		Binary operators require the following information:
		<ul>
			<li>Precedence: an integer relative to other operators which defines order of operations.</li>
			<li>Symbol: a String representing the actual operator. This is typically a single character but doesn't have to be.</li>
			<li>Node Class: A class which extends <code>com.mitchellbosecke.pebble.node.expression.NodeExpressionBinary</code> which handles compilation.</li>
			<li>Associativity: Either left or right depending on how the operator is used.</li>
		</ul>
	</p>
	<p>
		A unary operator is much the same except it's node class must be a class that extends
		<code>com.mitchellbosecke.pebble.node.expression.NodeExpressionUnary</code> and
		there is no associativity.
	</p>
	<p>
		The precedence values for existing core operators are as followed:
		<ul>
			<li><code>or</code> - 10</li>
			<li><code>and</code> - 15</li>
			<li><code>==</code> - 20</li>
			<li><code>!=</code> - 20</li>
			<li><code>&gt;</code> - 20</li>
			<li><code>&lt;</code> - 20</li>
			<li><code>&gt;=</code> - 20</li>
			<li><code>&lt;=</code> - 20</li>
			<li><code>+</code> - 30</li>
			<li><code>-</code> - 30</li>
			<li><code>not</code> - 50 (Unary Version)</li>
			<li><code>*</code> - 60</li>
			<li><code>/</code> - 60</li>
			<li><code>%</code> - 60</li>
			<li><code>is</code> - 100</li>
			<li><code>is not</code> - 100</li>
			<li><code>+</code> - 500 (Unary Version)</li>
			<li><code>-</code> - 500 (Unary Version)</li>
		</ul>
	</p>
	<h3>Tags</h3>
{% endblock %}