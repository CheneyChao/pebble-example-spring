{% extends "documentation/guides/guide" %}

{% block pageheader %}
	<h1>High Performance</h1> 
    <p>Concurrent evaluations and static typing.</p>
{% endblock pageheader %}

{% block guideTitle %}Integration with Spring 3{% endblock %}

{% block guideContent %}
		
		<h3>Overview</h3>
		<p>
			First of all, make sure to include the pebble-spring3 adapter.
			This will provide the necessary <code>ViewResolver</code> and <code>View</code> classes.
		</p>
		<p>
			<pre>{{ '
<dependency>
	<groupId>com.mitchellbosecke</groupId>
	<artifactId>pebble-spring3</artifact>
	<version>' | trim | escape }} {{ currentVersion }} {{ '</version>
</dependency>' | trim | escape }}</pre>
		</p>
		<p>
  			Secondly, make sure your templates are on the classpath (ex. /WEB-INF/templates/).
  			Now you want to define a {{ api(currentVersion, null, 'PebbleEngine') }} bean and a <code>PebbleViewResolver</code> in 
  			your servlet config.
	<pre class="xml">{{ '

<bean id="pebbleEngine" class="com.mitchellbosecke.pebble.PebbleEngine">
	<property name="strictVariables" value="false" />
	<property name="loader">
		<bean class="com.mitchellbosecke.pebble.spring.PebbleTemplateLoader" />
	</property>
</bean>

<bean id="viewResolver" class="com.mitchellbosecke.pebble.spring.PebbleViewResolver">
	<property name="prefix" value="\WEB-INF\templates\" />
	<property name="suffix" value=".html.peb" />
	<property name="pebbleEngine" ref="pebbleEngine" />
</bean>		
				' | trim | escape }}</pre> 
			</p>
			<p>
				Now the methods in your <code>@Controller</code> annotated classes
				can simply return the name of the template as you normally would
				if using JSPs. You can exclude the template file extension if you
				set it as the "suffix" property of the <code>PebbleViewResolver</code>.
  			</p>
		
		
{% endblock %}