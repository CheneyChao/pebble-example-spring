{% extends "documentation/guides/guide" %}

{% block pageheader %}
	<h1>High Performance</h1> 
    <p>Concurrent evaluations and static typing.</p>
{% endblock pageheader %}

{% block guideTitle %}High Performance Techniques{% endblock %}

{% block guideContent %}
		
		<h3>Concurrency</h3>
		<p>
			First and foremost, a {{ api(currentVersion, 'template', 'PebbleTemplate') }} object, once compiled,
			is completely thread safe. As long as the data backing the template is also thread safe, you
			can render that single template instance using multiple threads at once.
		</p>
		<p>
			The actual rendering of a template will typically occur in a sequential manner, from top to bottom.
			If, however, you provide an <code>ExecutorService</code> to the {{ api(currentVersion, null, 'PebbleEngine') }}
			and make use of the <code><a href="../tag/parallel">parallel</a></code> tag, you can have multiple threads
			render different sections of your template at one time. This is especially useful if one section of your 
			template is costly and will otherwise block the rendering of the rest of the template. 
		</p>
		<p>
			Although the initial template compilation process does not take full advantage of concurrency, it is still thread safe. You
			can have multiple threads attempt to compile the same template, using the same {{ api(currentVersion, null, 'PebbleEngine') }} instance,
			and all of them will end up with the same {{ api(currentVersion, 'template', 'PebbleTemplate') }} instance. 
			Although thread-safe, compilations of different templates using different threads will occur in a sequential manner (I'm
			hoping to change that fact in a future version).
		</p>
		
		<h3>Streaming</h3>
		<p>
			The use of the <code><a href="../tag/flush">flush</a></code> tag can be used to stream the rendered output
			as it's being rendered. This can significantly improve latency. 
		</p>
		
		<h3>HTML Evaluation Deferment (a.k.a Big Pipe)</h3>
		<p>
			This is a feature in the works, <strong>i.e. not yet developed</strong>. The basic
			idea is that you can quickly stream your bare-bones HTML to a user which contains placeholders for the "costly contents"
			and when the "costly contents" is finally done being rendered, it will be placed in the aforementioned placeholders. 
			What makes this	so special is that it happens with only one response from the server, i.e. no AJAX. More information
			about this feature <strong>coming soon</strong>.
		</p>
		
		<h3>Performance Pitfalls</h3>
		<p>
			<ul>
				<li>
					It is typically okay for a block to use the <code><a href="../tag/flush">flush</a></code> tag <strong>unless</strong>
					the contents of that block is being rendered using the <code><a href="../function/block">block</a></code> function. 
					Typically the <code><a href="../tag/flush">flush</a></code> tag will flush to the <code>Writer</code> that you 
					provided but the <code>block</code> function internally uses it's own <code>StringWriter</code> and therefore
					flushing will do no good.
				</li>
			
			
			</ul>
		</p>
		
		
{% endblock %}